\documentclass[fontsize=12pt,paper=a4,twoside]{scrartcl}

\newcommand{\grad}{\ensuremath{^{\circ}} }
\renewcommand{\strut}{\vrule width 0pt height5mm depth2mm}

\usepackage[utf8]{inputenc}
\usepackage[final]{pdfpages}
% obere Seitenränder gestalten können
\usepackage{fancyhdr}
\usepackage{moreverb}
% Graphiken als jpg, png etc. einbinden können
\usepackage{graphicx}
\usepackage{stmaryrd}
% Floats Objekte mit [H] festsetzen
\usepackage{float}
% setzt URL's schön mit \url{http://bla.laber.com/~mypage}
\usepackage{url}
% Externe PDF's einbinden können
\usepackage{pdflscape}
% Verweise innerhalb des Dokuments schick mit " ... auf Seite ... "
% automatisch versehen. Dazu \vref{labelname} benutzen
\usepackage[ngerman]{varioref}
\usepackage[ngerman]{babel}
\usepackage{ngerman}
% Bibliographie
\usepackage{bibgerm}
% Tabellen
\usepackage{tabularx}
\usepackage{supertabular}
\usepackage[colorlinks=true, pdfstartview=FitV, linkcolor=blue,
            citecolor=blue, urlcolor=blue, hyperfigures=true,
            pdftex=true]{hyperref}
\usepackage{bookmark}

\hyphenation{Arbeits-paket}

\newboolean{langversion} %Deklaration
\setboolean{langversion}{true} %Zuweisung ist 'false' für Blockkurs
\newcommand{\highlight}[1]{\textcolor{blue}{\textbf{#1}}}
\newcommand{\nurlangversion}[0]{%
\ifthenelse{\boolean{langversion}}{\highlight{Muss in SWP-2 ausgefüllt werden}}{\highlight{Entfällt in SWP-1}}}


\newcommand{\swp}[0]{\ifthenelse{\boolean{langversion}}%
{Software--Projekt 2}{Software--Projekt 1}}
\newcommand{\jahr}[0]{2014}
\newcommand{\semester}[0]{\ifthenelse{\boolean{langversion}}{WiSe}{SoSe}}

% erstes Argument: SWP-2, zweites SWP-1
\newcommand{\variante}[2]{\ifthenelse{\boolean{langversion}}{#1}{#2}}

% Damit Latex nicht zu lange Zeilen produziert:
\sloppy
%Uneinheitlicher unterer Seitenrand:
%\raggedbottom

% Kein Erstzeileneinzug beim Absatzanfang
% Sieht aber nur gut aus, wenn man zwischen Absätzen viel Platz einbaut
\setlength{\parindent}{0ex}

% Abstand zwischen zwei Absätzen
\setlength{\parskip}{1ex}

% Seitenränder für Korrekturen verändern
\addtolength{\evensidemargin}{-1cm}
\addtolength{\oddsidemargin}{1cm}

\bibliographystyle{gerapali}

% Lustige Header auf den Seiten
  \pagestyle{fancy}
  \setlength{\headheight}{70.55003pt}
  \fancyhead{}
  \fancyhead[LO,RE]{\swp\\ \semester \jahr
  \\Architekturbeschreibung}
  \fancyhead[LE,RO]{Seite \thepage\\\slshape \leftmark\\\slshape \rightmark}

%Etwas größere Zeilenabstände in Tabellen
\renewcommand{\arraystretch}{1.2}

%
% Und jetzt geht das Dokument los....
%

\begin{document}

% Lustige Header nur auf dieser Seite
  \thispagestyle{fancy}
  \fancyhead[LO,RE]{ }
  \fancyhead[LE,RO]{Universität Bremen\\FB 3 -- Informatik\\
  Prof. Dr. Rainer Koschke \\TutorIn: Karsten Hölscher}
  \fancyfoot[C]{}

% Start Titelseite
  \vspace{3cm}

  \begin{minipage}[H]{\textwidth}
  \begin{center}
  \bf
  \Large
  Software--Projekt 2 2014\\
  \smallskip
  \small
  VAK 03-BA-901.02\\
  \vspace{3cm}
  \end{center}
  \end{minipage}
  \begin{minipage}[H]{\textwidth}
  \begin{center}
  \vspace{1cm}
  \bf
  \Large Architekturbeschreibung\\
  \vspace{3ex}
   	  \begin{figure}[H]
      \centering
      \includegraphics[width=0.25\textwidth]{../WOYM.png}
      \end{figure}
  \vfill
  \end{center}
  \end{minipage}
  \vfill
  \begin{minipage}[H]{\textwidth}
  \begin{center}
  \sf
  \begin{tabular}{l}
  Tim Hansen \\
  Adrian Lück \\
  Jurij Schmidt\\
  \end{tabular}
  \\ ~
  \vspace{2cm}
  \\
  \it Version 1.3\\ ~
  \end{center}
  \end{minipage}

% Ende Titelseite

% Start Leerseite

\newpage

  \thispagestyle{fancy}
  \fancyhead{}
  \fancyhead[LO,RE]{\swp{} \\  \semester{} \jahr{}
  \\Architekturbeschreibung}
  \fancyhead[LE,RO]{Seite \thepage\\\slshape \leftmark\\~}
  \fancyfoot{}
  \renewcommand{\headrulewidth}{0.4pt}
  \tableofcontents

\newpage

  \fancyhead[LE,RO]{Seite \thepage\\\slshape \leftmark\\\slshape \rightmark}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Version und Änderungsgeschichte}

\begin{tabular}{ccl}
Version & Datum & Änderungen \\
\hline
1.0 & 29.10.2014 & Dokumentvorlage als initiale Fassung kopiert  \\
1.1 & 22.11.2014 & Erste vollständige Fassung der konzeptionellen und Datensicht\\
1.2 & 17.01.2015 & Paketdiagramm hinzugefügt. Datenmodell aktualisiert \\
1.3 & 01.02.2015 & Kapitel 7 hinzugefügt\\
\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Einführung}

\subsection{Zweck}
  
Die Architekturbeschreibung soll es anderen Entwicklern ermöglichen, den Aufbau der Software und Intentionen hinter bestimmten Design-Entscheidungen zu verstehen. Dadurch sollen Fremdentwickler in die Lage versetzt werden, die Software zu überarbeiten und Bugs zu beheben.

\subsection{Status}
Dieses Dokument gibt die Software-Architektur des finalen Produktes wieder.


  
\subsection{Definitionen, Akronyme und Abkürzungen}


\subsection{Referenzen}
Die folgenden Kapitel stützen sich im Wesentlichen auf die Vorlesungsfolien "`Software-Architektur 1"' der Veranstaltung "`Software-Projekt 1"' im Sommersemester 2014 an der Universität Bremen von Prof. Dr. Rainer Koschke.


\subsection{Übersicht über das Dokument}
\nurlangversion


\section{Globale Analyse}
\label{sec:globale_analyse}

\subsection{Einflussfaktoren}
\label{sec:einflussfaktoren}
{\it Hier sind Einflussfaktoren gefragt, die sich auf die Architektur
  beziehen. Es sind ausschließlich architekturrelevante
  Einflussfaktoren, und nicht z.B.\ solche, die lediglich einen
  Einfluss auf das Projektmanagement haben. Fragt Euch also bei jedem
  Faktor: Beeinflusst er wirklich die Architektur? Macht einen
  einfachen Test: Wie würde die Architektur aussehen, wenn ihr den
  Einflussfaktor E berücksichtigt? Wie würde sie aussehen, wenn Ihr E nicht
  berücksichtigt? Kommt in beiden Fällen dieselbe Architektur heraus,
  dann kann der Einflussfaktor nicht architekturrelevant sein.

  Es geht hier um Einflussfaktoren, die
  \begin{enumerate}
  \item sich über die Zeit ändern,
  \item viele Komponenten betreffen,
  \item schwer zu erfüllen sind oder
  \item mit denen man wenig Erfahrung hat.
  \end{enumerate}
  Die Flexibilität und Veränderlichkeit müssen ebenfalls charakterisiert werden. 
  \begin{enumerate}
  \item Flexibilität: Könnt Ihr den Faktor zum jetzigen Zeitpunkt beeinflussen?
  \item Veränderlichkeit: ändert der Faktor sich später durch äußere Einflüsse?
\end{enumerate}

  Unter Auswirkungen sollte dann beschrieben werden, {\em wie} der
  Faktor {\em was} beeinflusst. Das können sein:
  \begin{itemize}
  \item andere Faktoren
  \item Komponenten
  \item Operationsmodi
  \item Designentscheidungen (Strategien)
  \end{itemize}

  Verwendet eine eindeutige Nummerierung der Faktoren, um sie auf den
  Problemkarten einfach referenzieren zu können.  }\\

\subsubsection{Organisatorische Faktoren}
\renewcommand{\arraystretch}{1.4}
\begin{tabularx}{\textwidth}{|X|X|X|}
\hline
\textbf{Faktor} & \textbf{Flexibilität und Veränderlichkeit} & \textbf{Auswirkungen}\\\hline
\hline
\multicolumn{3}{|l|}{\textbf{O1: Management}}\\\hline
\multicolumn{3}{|l|}{O1.1: Zeitplan vs. Funktionsumfang}\\\hline
Der Zeitplan ist in jedem Fall einzuhalten. Ggf. muss dafür in Kauf genommen werden, dass gewisse Funktionen fehlen. & Dieser Faktor ist nicht flexibel oder veränderlich. & Nicht alle geplanten Funktionen können implementiert werden. Zunächst Beschränkung auf die Funktionen, die notwendig sind, um die Mindestanforderungen zu erfüllen.\\\hline

\multicolumn{3}{|l|}{\textbf{O2: Personal: Fähigkeiten, Interessen, Stärken, Schwächen}}\\\hline
\multicolumn{3}{|l|}{O2.1: Erstes größeres, selbständig auszuführendes Projekt}\\\hline
Für alle beteiligten Entwickler handelt es sich um das erste größere selbstständig auszuführende Projekt. & Dieser Faktor ist nicht flexibel oder veränderlich. & %TODO 
\\\hline

\multicolumn{3}{|l|}{\textbf{O3: Prozesse und Werkzeuge für die Entwicklungsschritte}}\\\hline

\multicolumn{3}{|l|}{\textbf{O4: Entwicklungszeitplan}}\\\hline
\multicolumn{3}{|l|}{O4.1: Auslieferung der Produktfunktionen}\\\hline
Es werden die absolut notwendigen Produktfunktionen (Mindestanforderungen) priorisiert. & Die Mindestanforderungen und damit die Prioritätensetzung können sich im Zeitverlauf verändern (inbes. abhängig von O5.1). & Kann O1.1 beeinflussen.\\\hline

\multicolumn{3}{|l|}{\textbf{O5: Entwicklungsbudget}}\\\hline
\multicolumn{3}{|l|}{O5.1: Anzahl der Entwickler}\\\hline
Es sind maximal sechs Entwickler am Projekt beteiligt. & Es können keine weitere Entwickler hinzugezogen werden. Teilnehmende Entwickler können temporär oder komplett ausfallen. & Ein temporärer Ausfall kann Faktor 01.1 leicht beeinflussen. Bei komplettem Ausfall eines Entwicklers werden die Mindestanforderungen verändert und damit O4.1 und O1.1 beeinflusst.\\\hline
\end{tabularx}\\
\clearpage

\subsubsection{Technische Faktoren}

\begin{tabularx}{\textwidth}{|X|X|X|}
\hline
\textbf{Faktor} & \textbf{Flexibilität und Veränderlichkeit} & \textbf{Auswirkungen}\\\hline
\hline
\multicolumn{3}{|l|}{\textbf{T1: Hardware}}\\\hline
\multicolumn{3}{|l|}{T1.1: Hardwarelandschaft des Kunden ist zu berücksichtigen}\\\hline
Die Software muss auf einem Rechner mit 4 GB RAM, 70 GB Festplattenspeicher, einer Dual-Core-CPU mit 2,9 GHz Takt lauffähig sein und auf einem Monitor mit einer Auflösung von 1280 x 1024 korrekt dargestellt werden. & Dieser Faktor ist nicht flexibel. In Zukunft könnte sich die Hardwarelandschaft des Kunden jedoch verändern, wobei davon auszugehen ist, dass höchstens ein Up- und kein Downgrade stattfindet. & %TODO
 \\\hline

\multicolumn{3}{|l|}{\textbf{T2: Software}}\\\hline
\multicolumn{3}{|l|}{T2.1: Betriebssystem}\\\hline
Die Software soll auf allen gängigen Betriebssystemen (Microsoft Windows, Linux, Mac-OS) lauffähig sein. & Dieser Faktor ist nicht flexibel, aber ggf. veränderlich, da neue Betriebssystem erscheinen können. & Bei der Entwicklung muss darauf geachtet werden, betriebssystemunabhängige Komponenten zu verwenden.\\\hline
\multicolumn{3}{|l|}{T2.2: Verwendung von JavaServer Faces bzw. Primefaces}\\\hline
Für die grafische Darstellung der Software wird JavaServer Faces bzw. Primefaces verwendet. & Dieser Faktor könnte zu Beginn noch verändert werden, eine Veränderung zu einem späteren Zeitpunkt wäre eher unwahrscheinlich. & Nimmt starken Einfluss auf die Implementierung der View- und der Controller-Komponente. Alle Datenklassen benötigen außerdem Getter- und Setter-Methoden für alle ihre Attribute. \\\hline
\end{tabularx} \clearpage

\begin{tabularx}{\textwidth}{|X|X|X|}
\hline
\textbf{Faktor} & \textbf{Flexibilität und Veränderlichkeit} & \textbf{Auswirkungen}\\\hline
\hline
\multicolumn{3}{|l|}{T2.3: Verwendung der JPA-Implementierung Eclipselink}\\\hline
Für die Anbindung an das relationale Datenbanksystem wird das JPA-Framework Eclipselink verwendet. & Dieser Faktor ist flexibel, es könnte grundsätzlich auch jedes andere JPA-Framework gewählt werden bzw. auch gar keines solcher Frameworks. Theoretisch ist der Faktor auch veränderlich. Wenn etwa Probleme mit dem Framework auftreten könnte in Betracht gezogen werden, es durch ein anderes auszutauschen. & Dieser Faktor beeinflusst vor allem die Implementierung der Persistenz-Komponente. \\\hline
\multicolumn{3}{|p{\dimexpr\textwidth-2\tabcolsep\relax}|}{T2.4: Verwendung des Command-Entwurfmusters in Kombination mit dem Composite- und Memento-Entwurfmuster}\\\hline
Für die geeignete Erfüllung von Faktor P1.1 soll das Command-Entwurfsmuster in Kombination mit dem Composite- und Memento-Entwurfsmuster implementiert werden. Das Composite-Entwurfsmuster würde dann die Erstellung von Macro-Commands erlauben. Das Memento-Entwurfsmuster erlaubt die gekapselte Datenspeicherung für Update-Commands. & Dieser Faktor ist flexibel und gemäß P1.1 veränderlich. & Beeinflusst die Implementierung der Model-Komponente deutlich. Da die gesamte Logik für das Speichern, Aktualisieren und Löschen von Objekten auf Commands aufgebaut sein muss. Zudem müssen alle notwendigen Klassen eine eigene Memento-Klasse besitzen. \\\hline
\end{tabularx}

\begin{tabularx}{\textwidth}{|X|X|X|}
\hline
\textbf{Faktor} & \textbf{Flexibilität und Veränderlichkeit} & \textbf{Auswirkungen}\\\hline
\hline
\multicolumn{3}{|l|}{T2.5: Verwendung des Factory-Patterns für Delete-Commands}\\\hline
Geht aus dem Faktor T2.4 hervor. Da beim Löschen von Objekten einige Abhängigkeiten zu berücksichtigen sind, damit es in der Datenbank nicht zu Fremdschlüssel-Verletzungen kommt, bietet sich die Implementierung einer Klasse, die Macro-Delete-Commands unter Berücksichtigung der Abhängigkeiten erzeugt, nach dem Factory-Pattern an.& Dieser Faktor ist flexibel und gemäß 2.4 veränderlich. & Beeinflusst die Implementierung der Model-Komponente. \\\hline
\multicolumn{3}{|l|}{\textbf{T3: Architekturtechnologie}}\\\hline

\multicolumn{3}{|l|}{\textbf{T4: Standards}}\\\hline
\multicolumn{3}{|l|}{T4.1: Leichtgewichtiges eingebettetes relationales Datenbanksystem}\\\hline
Die Verwendung einer leichtgewichtigen, eingebetteten relationalen Datenbank ist vorgeschrieben. & Dieser Faktor ist nicht flexibel oder veränderlich. & \\\hline
\end{tabularx}

\clearpage

\subsubsection{Produktfaktoren}
\begin{tabularx}{\textwidth}{|X|X|X|}
\hline
\textbf{Faktor} & \textbf{Flexibilität und Veränderlichkeit} & \textbf{Auswirkungen}\\\hline
\hline
\multicolumn{3}{|l|}{\textbf{P1: Produktfunktionen}}\\\hline
\multicolumn{3}{|l|}{P1.1: Mehrstufiges Rückgängigmachen von Aktionen}\\\hline
Um die Lernförderlichkeit zu unterstützen, soll es den Benutzern möglich sein, Aktionen mehrstufig rückgängig zu machen. & Dieser Faktor ist nicht flexibel, kann im Zuge von O4.1 jedoch ggf. wegfallen. & Bei der Planung und Implementierung der Geschäftslogik muss darauf geachtet werden, diesen Faktor geeignet zu berücksichtigen. Aus diesem Einflussfaktor geht T2.3 hervor.
\\\hline
\multicolumn{3}{|l|}{P1.2: Systemeinstellungen}\\\hline
Die Software soll verschieden Systemeinstellungen bieten, die etwa erlauben, zu verplanende Wochentage, Start- und Ende eines Wochentages, Backup-Einstellungen usw. festzulegen. & Dieser Faktor ist nicht flexibel, kann im Zuge von O4.1 aber ggf. wegfallen. & Es muss eine Möglichkeit geben, solcherlei Einstellungen zu verändern und sie über einen Systemstart hinaus zu speichern.\\\hline
\multicolumn{3}{|l|}{\textbf{P2: Benutzerschnittstelle}}\\\hline

\multicolumn{3}{|l|}{\textbf{P3: Performanz}}\\\hline

\multicolumn{3}{|l|}{\textbf{P4: Verlässlichkeit}}\\\hline

\multicolumn{3}{|l|}{\textbf{P5: Fehlererkennung, -bericht, -behandlung}}\\\hline

\multicolumn{3}{|l|}{\textbf{P6: Service}}\\\hline
\end{tabularx}\\


\subsection{Probleme und Strategien}
\label{sec:strategien}

{\it Aus einer Menge von Faktoren ergeben sich Probleme, die nun in
  Form von Problemkarten beschrieben werden. Diese resultieren
  z.B. aus
  \begin{itemize}
  \item Grenzen oder Einschränkungen durch Faktoren
  \item der Notwendigkeit, die Auswirkungen eines Faktors zu begrenzen
  \item der Schwierigkeit, einen Produktfaktor zu erfüllen, oder
  \item der Notwendigkeit einer allgemeinen Lösung zu globalen
    Anforderungen.
  \end{itemize}
  Dazu entwickelt Ihr Strategien, um mit den identifizierten Problemen
  umzugehen.

  Achtet auch hier darauf, dass die Probleme und Strategien wirklich
  die Architektur betreffen und nicht etwa das Projektmanagement. Die
  Strategien stellen im Prinzip die Designentscheidungen dar. Sie
  sollten also die Erklärung für den konkreten Aufbau der
  verschiedenen Sichten liefern.}


\textit{Beschreibt möglichst mehrere Alternativen und gebt
  an, für welche Ihr Euch letztlich aus welchem Grunde entschieden
  habt. Natürlich müssen die genannten Strategien in den folgenden
  Sichten auch tatsächlich umgesetzt werden!}

\textit{Ein sehr häufiger Fehler ist es, dass SWP-Gruppen
  arbeitsteilig vorgehen: die eine Gruppe schreibt das Kapitel zur
  Analyse von Faktoren und zu den Strategien, die andere Gruppe
  beschreibt die diversen Sichten, ohne dass diese beiden Gruppen sich
  abstimmen. Natürlich besteht aber ein Zusammenhang zwischen den
  Faktoren, Strategien und Sichten. Dieser muss erkennbar sein, indem
  sich die verschiedenen Kapitel eindeutig aufeinander beziehen.}

\section{Konzeptionelle Sicht}
\label{sec:konzeptionell}

\begin{figure}[H]
\centering
\includegraphics[width=0.45\textwidth]{konzeptsicht.pdf}
\end{figure}


Der Client besteht aus der GUI-, Model- und Persistence-Komponente. Die GUI-Komponente ist wiederum unterteilt in View und Controller. Die View-Komponente stellt Daten (in Form von Eingaben des Nutzers) für die Controller-Komponente bereit. Die Controller-Komponente kontrolliert die Darstellung der View-Komponente und nutzt durch die Model-Komponente bereitgestellte Möglichkeiten, Daten zu modifizieren oder bestimmte verarbeitete Daten zu erhalten. Auch nutzt die Controller-Komponente die von der Persistence-Komponente bereitgestellten Operationen um Daten aus der Datenbank zu lesen. Auch die Model-Komponente nutzt durch die Persistence-Komponente bereitgestellte Operationen, greift jedoch nicht nur auf lesende Operationen zu, sondern hat vollständigen Zugriff auch auf schreibende Methoden. Die Persistence-Komponente ist unabhängig von den anderen Komponenten. Die Software ist also nach einer Schichtenarchitektur aufgebaut.

\section{Modulsicht}
\label{sec:modulsicht}

{\it
Diese Sicht beschreibt den statischen Aufbau des Systems mit Hilfe von
Modulen, Subsystemen, Schichten und Schnittstellen. 
Diese Sicht ist hierarchisch, d.h. Module werden in Teilmodule
zerlegt. Die Zerlegung endet bei Modulen, die ein klar umrissenes
Arbeitspaket für eine Person darstellen und in einer Kalenderwoche
implementiert werden können. Die Modulbeschreibung der Blätter dieser
Hierarchie muss genau genug und ausreichend sein, um das Modul 
implementieren zu können.

Die Modulsicht wird durch {UML}-Paket- und Klassendiagramme visualisiert.

Die Module werden durch ihre Schnittstellen beschrieben. 
Die Schnittstelle eines Moduls $M$ ist die Menge aller Annahmen, die
andere Module über $M$ machen dürfen, bzw.\ jene Annahmen, die $M$
über seine verwendeten Module macht (bzw. seine Umgebung, wozu auch
Speicher, Laufzeit etc.\ gehören).
Konkrete Implementierungen dieser Schnittstellen sind das Geheimnis des Moduls
und können vom Programmierer festgelegt werden. Sie sollen hier
dementsprechend nicht beschrieben werden. 

Die Diagramme der Modulsicht sollten die zur Schnittstelle gehörenden Methoden
enthalten. Die Beschreibung der einzelnen Methoden (im Sinne der Schnittstellenbeschreibung)
geschieht allerdings per Javadoc im zugehörigen Quelltext. Das bedeutet, dass Ihr
für alle Eure Module Klassen, Interfaces und Pakete erstellt und sie mit den Methoden der
Schnittstellen verseht. Natürlich noch ohne Methodenrümpfe bzw.\ mit minimalen Rümpfen.
Dieses Vorgehen vereinfacht den Schnittstellenentwurf und stellt Konsistenz sicher.

Jeder Schnittstelle liegt ein
Protokoll zugrunde. Das Protokoll beschreibt die Vor- und
Nachbedingungen der Schnittstellenelemente. Dazu gehören die erlaubten
Reihenfolgen, in denen Methoden der Schnittstelle aufgerufen werden
dürfen, sowie Annahmen über Eingabeparameter und Zusicherungen über
Ausgabeparameter. Das Protokoll von Modulen wird in der Modulsicht beschrieben.
Dort, wo es sinnvoll ist, sollte es mit Hilfe von Zustands- oder
Sequenzdiagrammen spezifiziert werden. Diese sind dann einzusetzen, wenn der
Text allein kein ausreichendes Verständnis vermittelt (insbesondere
bei komplexen oder nicht offensichtlichen Zusammenhängen).

Der Bezug zur konzeptionellen Sicht muss klar ersichtlich sein. Im
Zweifel sollte er explizit erklärt werden. Auch für diese Sicht muss
die Entstehung anhand der Strategien erläutert werden.
}

\subsection{Paketdiagramm}
Die Software ist aufgeteilt in fünf große Pakete, die jeweils noch Unterpakte besitzen. In dem nachfolgend aufgeführten Paketdiagramm sind nur die Abhängigkeiten zwischen den großen Pakten aufgeführt, um die Darstellung übersichtlicher zu halten.\\

\begin{itemize}
\item \textit{org.woym.persistence}: In diesem Paket befinden sich alle Klassen, die Methoden für lesenden oder schreibenden Zugriff auf der Datenbank enthalten. Im Unterpaket \textit{org.woym.persistence.spec} befinden sich die zugehörigen Interfaces (s. Kapitel \ref{subsec:persistence}).
\item \textit{org.woym.common}: In diesem Paket  bzw. in den jeweiligen Unterpaketen befinden sich Klassen, welche von Klassen aus fast allen anderen Paketen verwendet werden (s. Kapitel \ref{subsec:Common}). 
\item \textit{org.woym.controller}: Dieses Paket enthält alle Controller, welche die Eingaben von der GUI verarbeiten (s. Kapitel \ref{subsec:Controller}.
\item \textit{org.woym.ui}: Dieses Paket enthält JSF-Validatoren und -Converter, sowie Hilfsklassen für bestimmte Operationen auf der GUI (s. Kapitel \ref{subsec:UI}).
\item \textit{org.woym.logic}: In diesem Paket befinden sich alle Klassen, die die Geschäftslogik implementieren (s. Kapitel \ref{subsec:logic}).
\end{itemize}
 


\begin{figure}[H]
\includegraphics[width=\textwidth]{packages.pdf}
\end{figure}

\subsection{Persistence}
\label{subsec:persistence}

Die Persistenzschicht ist für ein Single-User-System konzipiert und besteht aus drei Klassen. Die Singleton-Klasse \texttt{DataBase} stellt die unterste Ebene dar. Dort wird der EntityManager erzeugt, der für alle Datenbankanfragen von \texttt{DataAccess} verwendet wird. Außerdem bietet sie Methoden an, die ein Backup der Datenbank erzeugen bzw. ein Backup wiederherstellen. \texttt{DataBase} erweitert die Java-Klasse \texttt{Observable}, da es für die Wiederherstellung eines Backups notwendig ist, die Datenbank einmal komplett herunterzufahren und danach dementsprechend ein neuer EntityManager verwendet wird. Dies muss den beobachtenden Klassen mitgeteilt werden.\\
Die Singleton-Klasse \texttt{DataAccess} implementiert das Java-Interface \texttt{Observer} und wird bei Erzeugung bei \texttt{DataBase} als Observer registriert. Zudem implementiert sie das Interface \texttt{IDataAccess}, welches alle DAO-Interfaces implementiert und damit die notwendigen Datenzugriffsmethoden beschreibt. Die Klasse \texttt{DataAccess} stellt also für alle Klassen auf einer oberen Ebene die Schnittstelle zur Datenbank dar.\\
Die letzte Klasse der Persistenzschicht ist \texttt{DataBaseServletListener}, welche das Java-Interface \texttt{ServletContextListener} implementiert. Sie ruft mit dem Start des Servlet-Containers die \textit{setUp()}-Methode von \texttt{DataBase} auf.\\

Bevor die Methoden von \texttt{DataAcess} oder \texttt{DataBase} verwendet werden können, muss mindestens einmal die Methode \textit{setUp()} der Klasse \texttt{DataBase} aufgerufen werden, da diese den von \texttt{DataAccess} benötigten EntityManager erzeugt.\\
Die Methoden des Interfaces \texttt{IDataAccess} dürfen in beliebiger Reihenfolge aufgerufen werden. Methoden, welche als Rückgabewert eine Liste haben, geben in allen Fällen eine Liste zurück, diese kann also leer sein. Methoden, welche als Rückgabewert ein einzelnes Objekt einer Klasse besitzen, geben ein gemäß der JavaDoc-Beschreibung entsprechendes Objekt der Klasse oder \textbf{null} zurück, falls kein entsprechendes Objekt vorhanden ist. 


\includepdf[landscape]{persistence.pdf}


\subsection{Common}
\label{subsec:Common}
Im Paket \textit{org.woym.common} befinden sich -- wie vorher bereits angemerkt -- Klassen, welche von Klassen aus fast allen anderen Paketen verwendet werden.\\
Das Paket \textit{org.woym.common.config} beinhaltet das \texttt{DefaultConfigEnum}, welches alle Einstellungsoptionen der Software mit ihren Standardwerten enthält. Die Klasse \texttt{Config} erzeugt eine Properties-Datei und gewährt anderen Klassen Zugriff auf dort eingetragene Werte. Bevor die anderen Methoden der Klasse aufgerufen werden können, muss mindestens einmal die Methode \textit{init()} aufgerufen werden. 
\\
Die Klasse \texttt{ConfigServletListener} implementiert das Java-Interface \texttt{ServletContextListener} und sorgt dafür, dass mit dem Start des Servlet-Containers einmal die \textit{init()}-Methode von \texttt{Config} aufgerufen wird.\\

Das Paket \textit{org.woym.common.messages} beinhaltet vier Enums mit Statusnachrichten. Die Klasse \texttt{MessageHelper} stellt Methoden bereit, welche für die Übergabe einer entsprechenden Nachricht und ggf. zusätzlichen Parametern eine \texttt{FaceMessage} zurückgibt. Die Methoden können in beliebiger Reihenfolge aufgerufen werden.\\

Das Paket \textit{org.woym.common.exceptions} enthält lediglich die selbst angelegten Exceptions. \\

Das Paket \textit{org.woym.common.objects} ist hier nicht vollständig dargestellt (s. Kapitel \ref{subsubsec:Objects}), da dies zu unübersichtlich wäre, stattdessen ist nur das Unterpaket \textit{org.woym.common.objects.spec} dargestellt. Dieses enthält drei Interfaces. \texttt{IMemento} dient lediglich der Vereinheitlichung aller einzelnen Memento-Klassen unter einem gemeinsamen Interface. Da die Memento-Klassen nach außen hin vollständig opak sind und keinerlei Methoden bereitstellen, ist es sinnvoll, sie unter einem Interface zu vereinheitlichen, um sie von außen als gleichrangige Klassen zu verwenden. Das Interface \texttt{IActivityObject} dient der Vereinheitlichung von Klassen, deren Objekte Teil der Klasse \texttt{Activity} sein können. \\
Das Interface \texttt{IMementoObject} stellt Methoden für alle Klassen bereit, welche eine eigene Memento-Klasse definieren.\clearpage


\begin{figure}[H]
\includegraphics[width=\textwidth]{common.pdf}
\end{figure}
\newpage

\subsubsection{Objects}
\label{subsubsec:Objects}
Bei dem auf der folgenden Seite dargestellten Klassendiagramm zu den Datenobjekten ist es wichtig, dass alle Entitäten die gemeinsame abstrakte Superklasse \texttt{Entity} (oben rechts) besitzen. Die Vereinheitlichung unter dieser Klasse wird an einigen Stellen genutzt, um eine etwas allgemeinere Implementierung zu ermöglichen. Zudem stellt sie eine \textit{persist}-, \textit{update}- und \textit{delete}-Methoden für die erbenden Klassen bereit.\\
Ansonsten sollte auch die Teil-von-Beziehung zwischen den Entitäten und den zugehörigen Memento-Klassen herauszustellen. Die Memento-Klassen sind statische innere Klassen ihrer jeweiligen Entitätenklasse und bieten einen package-private Konstruktor, so dass dieser ansonsten nicht von außen verwendet werden kann. Auch bieten die Mementos nach außen hin keine Methoden. Sie sind also für alle anderen Klassen -- außer der zugehörigen Entitätenklasse -- vollständig opak.\\
Für die Speicherung von Wegzeiten existiert die Singleton-Klasse \texttt{TravelTimeList}, welche die statische Klasse \texttt{Edge} enthält. Eine Liste von \texttt{Edge}-Objekten in \texttt{TravelTimeList} repräsentiert die Wegzeiten zwischen je zwei Standorten. Es existiert immer nur ein \texttt{TravelTimeList}-Objekt in der Datenbank. Ist bei Aufruf von \textit{getInstance} noch keines vorhanden, wird eins angelegt.\\
Alle weiteren Assoziationen sollten in Kapitel \ref{sec:datensicht} erläutert werden.

\includepdf[landscape]{objects.pdf}


\subsection{Controller}
\label{subsec:Controller}

Im Paket \textit{org.woym.controller} befinden sich die Backing Beans für die verschiedenen JSF-Seiten. \\
Die Klasse \texttt{GUIController} stellt die Undo- und Redo-Funktionalität für alle JSF-Seiten bereit und befindet sich daher im übergeordneten Paket.\\
Im Paket \textit{org.woym.controller.manage} befinden sich die Backing Beans für die JSF-Seiten der Systemeinrichtung und im Paket \textit{org.woym.controller.planning} die Backing Beans für die JSF-Seiten der Planung. Die Zusammenhänge zwischen den JSF-Seiten und den Backing Beans sind hier nicht darstellbar. 

\includepdf[landscape]{controller.pdf}

\subsection{UI}
\label{subsec:UI}

Im Paket \textit{org.woym.ui.converters} befinden sich die JSF-Converter und im Paket \textit{org.woym.ui.validators} die JSF-Validatoren. Das Paket \textit{org.woym.ui.util} enthält Hilfsklassen für die Backing Beans der Planungsseite. Diese Hilfsklassen dienen im Wesentlichen der Unterstützung zur korrekten Darstellung der Elemente auf dieser Seite.\clearpage

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{ui.pdf}
\end{figure}

\subsection{Logic}
\label{subsec:logic}
Auf der Logikebene wurde das Command-Pattern verwendet, um ein Undo und Redo für alle Aktionen anbieten zu können. Die entsprechenden Klassen befinden sich im Paket \textit{org.woym.logic.command}. \\
Das Interface \texttt{ICommand} spezifiziert die Methoden eines konkreten Commands. Implementiert wird das Interface von den Klassen \texttt{AddCommand}, \texttt{UpdateCommand}, \texttt{DeleteCommand} und \texttt{MacroCommand}. Wobei ein \texttt{MacroCommand} zusätzlich eine Liste von \texttt{ICommand}-Objekten enthält. Für die Methoden gibt es eine klare Ausführungsreihenfolge. Nach Erzeugung eines ICommand-Objektes muss zunächst \textit{execute()} aufgerufen werden, danach dürfen alternierend \textit{undo()} und \textit{redo()} beliebig oft aufgerufen werden. \\

Neben den Commands befindet sich im Paket \textit{org.woym.logic.command} auch die Singleton-Klasse \texttt{CommandCreator}, welche nach dem Factory-Entwurfsmuster drei öffentliche Methode \textit{createDeleteCommand(Entity)}, \textit{createEmployeeUpdateAddWorkingHours(Activity)} und \textit{createEmployeeUpdateSubtractWorkingHours(Activity)} anbietet. Die Methode \textit{createDeleteCommand(Entity)} erzeugt für ein übergebenes \textit{Entity}-Objekt ein MacroCommand zum Löschen dieses Objektes, welches in der korrekten Abfolge alle Abhängigkeiten auflöst, und gibt dieses zurück. Die Methode darf beliebig aufgerufen werden. Für nähere Informationen siehe JavaDoc.\\
Die anderen beiden Methoden erzeugen jeweils ein \texttt{MacroCommand}, welches allen Mitarbeitern der übergebenen Aktivität entweder die Dauer ihrer Teilnahme an der Aktivität zu den verteilten Wochenstunden dazu addiert oder sie abzieht, und geben dieses zurück.\\

Im Paket \textit{org.woym.logic} befindet sich dann die Klasse \texttt{CommandHandler}, diese übernimmt für die korrekte Undo-/Redo-Funktionalität die Ausführung der Commands. Für die Ausführungsreihenfolge der Methoden gilt dasselbe, wie für die \texttt{ICommand}-Implementierungen. Der \texttt{CommandHandler} besitzt zwei Listen vom Typ \texttt{ILimitedQueue}. Die eine speichert alle Commands, die rückgängig gemacht werden sollen, die andere alle Commands, die wiederholt werden sollen. Bei einem Aufruf von \textit{execute(ICommand)} wird das Command also zunächst der Undo-Liste hinzugefügt, wird dann \textit{undo} aufgerufen, wird es der Redo-Liste hinzugefügt und bei anschließendem Aufruf von \textit{redo} wieder der Undo-Liste.\\
Im Paket \textit{org.woym.logic} befinden sich außerdem die zwei Implementierungen \texttt{SuccessStatus} und \texttt{FailureStatus} des Interfaces \textit{IStatus}. Diese repräsentieren die erfolgreiche bzw. fehlgeschlagene Ausführung einer Aktion.\\
Zudem befindet sich in dem Paket auch die Klasse \texttt{BackupRestoreHandler}. Diese implementiert das Interface \texttt{ServletContextListener}, so dass mit dem Start des Servlet-Containers der \texttt{ScheduledExecutorService} gestartet wird, welcher die automatischen Backups des Systems übernimmt. Für die Erstellung der Backups wird die Methode \textit{backup(String)} der Klasse verwendet. Diese führt ein Datenbankbackup durch Ausführung der Methode \textit{backup(String)} der Klasse \texttt{DataBase} aus und fügt diesem zusätzlich die Properties-Datei mit den aktuellen Systemeinstellungen hinzu. Die Methode \textit{restore(String)} stellt ein Datenbank-Backup unter Verwendung der Methode \textit{restore(String)} der Klasse \texttt{DataBase} wieder her. Zusätzlich wird die in dem Backup gespeicherte Properties-Datei wiederhergestellt. \\
Das Paket \textit{org.woym.logic.util} enthält -- abgesehen von der Klasse \texttt{LimitedQueue} -- Klassen, welche Logikoperationen unter Verwendung anderer Klasse aus dem Paket \textit{org.woym.logic} für Klassen des Paktes \textit{org.woym.controller} und dessen Subpakete bereitstellen. Die Klasse \texttt{SchoolclassIdentifierUtil} bietet eine Methode, welche alle gemäß den Einstellungen noch verfügbaren Bezeichner für Schulklassen des übergebenen Jahrgangs zurückgibt. In die Klasse \texttt{ConfigControllerUtil} wurden einige umfangreichere Operationen ausgelagert, die vom \texttt{ConfigController} benötigt werden. Die Methoden können grundsätzlich in beliebiger Reihenfolge aufgerufen werden.\\
Die Klasse \texttt{ActivityValidator} bietet fünf öffentliche Methoden, wobei lediglich die Methode \textit{validateActivity(Activity, TimePeriod)} vom \texttt{PlanningController} aufgerufen wird. Da diese Methode prüft, ob die übergebene Aktivität am übergebenen Zeitraum eingefügt werden kann oder ob eine Überschneidung vorliegt, wird sie vor dem finalen Hinzufügen oder Aktualisieren einer Aktivität aufgerufen.\\
Die Klasse \texttt{ActivityParser} überführt in den Methoden \textit{getActivityModel(Teacher)}, \textit{getActivityModel(Schoolclass)}, \textit{getActivityModel(PedagogicAssistant)} und \textit{getActivityModel(Room)} alle Aktivitäten des übergebenen Objektes in ein \texttt{ScheduleModel}, so dass diese optisch dargestellt werden können. Diese Methoden können in beliebiger Reihenfolge ausgeführt werden.
 
\includepdf[landscape]{logic.pdf}





\section{Datensicht}
\label{sec:datensicht}
  
\subsection{Datenmodell}
Auf der folgenden Seite ist das Datenmodell dargestellt. Danach folgt eine Beschreibung der einzelnen Assoziationen. Das Datenmodel beinhaltet keine implementierungsspezifischen Details. Diese sind im Klassendiagramm zu Kapitel \ref{subsubsec:Objects} zu erkennen.
\includepdf[landscape]{datenmodell.pdf}
Im Folgenden soll die einzelnen Assoziationen erläutert werden.\\

\begin{tabularx}{\textwidth}{|p{0.6cm}|p{5cm}|X|}
\hline
\textbf{Nr.} & \textbf{Assoziation} & \textbf{Beschreibung} \\\hline
1 	& \textit{Employee} -- ChargeableCompensation	& Ein Mitarbeiter kann eine beliebige Anzahl
	an anrechenbaren Ersatzleistungen besitzen. Eine spezifische anrechenbare Ersatzleistung ist immer nur einem Mitarbeiter zugeordnet. \\\hline
2	& \textit{Employee} -- TimePeriod		& Ein Mitarbeiter hat eine beliebige Menge von 
	Zeiträumen als Zeitwünsche, also als Zeiten zu denen er gerne frei haben möchte. \\\hline
3	& \textit{Employee} -- \textit{ActivityType} & Einer beliebigen Anzahl von Mitarbeitern kann
	eine beliebige Anzahl von Aktivitätstypen als mögliche Stundeninhalte zugeordnet sein. Diese Assoziationen sind also komplett optional. \\\hline
4	& Schoolclass -- LessonType -- Integer \newline
	  AcademicYear -- LessonType -- Integer				& Eine Schulklasse und ein Jahrgang besitzen Unterrichtsbedarfe. Dies wird durch eine Zuordnung von Integer-Werten zu LessonType-Objekten realisiert. Jedes LessonType-Objekt darf in Kombination mit einer Klasse / einem Jahrgang nur einmal vorkommen. \\\hline
5	& Schoolclass -- Teacher 				& Eine beliebige Anzahl an Schulklassen hat genau
	einen Klassenlehrer. Ein Lehrer kann Klassenlehrer mehrere Schulklassen sein. \\\hline
6	& AcademicYear -- Schoolclass 			& Ein AcademicYear-Objekt besteht aus einer beliebigen 
	Anzahl Schoolclass-Objekten. Wird das AcademicYear-Objekt gelöscht, werden auch alle dazu gehörigen Schoolclass-Objekte gelöscht.\\\hline
7	& \textit{Activity} -- TimePeriod				& Einer Aktivität steht immer genau ein
	Zeitraum gegenüber.\\\hline
8	& \textit{Activity} -- Room						& Eine Aktivität ist mindestens einem, kann 
	aber mehreren Räumen zugeordnet sein.\\\hline
\end{tabularx}

\begin{tabularx}{\textwidth}{|p{0.6cm}|p{5cm}|X|}
\hline
9 	& \textit{Activity} -- EmployeeTimePeriods		& An einer Aktivität kann eine beliebige
	Anzahl an Mitarbeitern teilnehmen, da diese früher gehen oder später kommen können, wird jedem Mitarbeiter eine eigene Liste von Zeiträumen zugeordnet. Dies wird durch die Klasse \texttt{EmployeeTimePeriods} realisiert. Einer Aktivität kann eine beliebige Zahl von EmployeeTimePeriods-Objekten zugeordnet sein, aber ein spezifisches EmployeeTimePeriod-Objekt ist immer nur genau einer Aktivität zugeordnet. \\\hline
10	& \textit{Activity} -- Schoolclass				& Eine beliebige Anzahl von Aktivitäten
	besitzt eine beliebige Anzahl von Schulklassen als Teilnehmer. Schulklassen können die Aktivität nicht
	frühzeitig verlassen, daher gilt für sie der für die Aktivität festgelegte Zeitraum.\\\hline
11	& Meeting -- MeetingType 			 & Eine Aktivität vom Typ Meeting hat genau einen
	MeetingType. Ein MeetingType kann mehreren Aktivitäten vom Typ Meeting zugeordnet sein. \\\hline
12	& Project -- ProjectType			& Eine Aktivität vom Typ Project hat genau einen
	ProjectType. Ein ProjectType kann mehreren Aktivitäten vom Typ Project zugeordnet sein. \\\hline
13	& Lesson -- LessonType				& Eine Aktivität vom Typ Lesson hat genau einen
	LessonType. Ein LessonType kann mehreren Aktivitäten vom Typ Lesson zugeordnet sein. \\\hline
14	& CompoundLesson -- LessonType & Eine CompoundLesson (Bandunterricht) hat mindestens ein bis 
	beliebig viele LessonType-Objekte. \\\hline
15 	& EmployeeTimePeriods -- Employee 				& Eine beliebige Anzahl
	EmployeeTimePeriods-Objekte besitzt genau einen Lehrer. Ein Lehrer kann Teil einer beliebigen Anzahl von EmployeeTimePeriods-Objekten sein. \\\hline
16	& EmployeeTimePeriods -- TimePeriod 			& Ein EmployeeTimePeriods-Objekt besitzt
	mindestens eine bis beliebig viele TimePeriod-Objekte. Ein spezifisches TimePeriod-Objekt ist immer nur Teil von genau einem EmployeeTimePeriods-Objekt. \\\hline
\end{tabularx}

\begin{tabularx}{\textwidth}{|p{0.6cm}|p{5cm}|X|}
\hline
17 	& TimePeriod -- Weekday & Ein TimePeriod-Objekt hat genau einen Wochentag, ein Wochentag kann 
	mehreren TimePeriod-Objekten zugeordnet sein.\\\hline 
18	& Location -- Room						& Ein Standort besteht aus beliebig vielen Räumen. 
	Wird der Standort gelöscht, werden auch die Räume gelöscht.\\\hline
19	& \textit{ActivityType} -- Room					& Einer beliebigen Anzahl von Aktivitätstypen
	kann die Ausführung in einer beliebigen Anzahl von Räumen zugeordnet sein. \\\hline
20	& \textit{ActivityType} -- ColorEnum 		& Ein Aktivitätstyp hat genau eine Farbe oder keine 
	Farbe. Eine Farbe kann Teil mehrere Aktivitätstypen sein.\\\hline
21	& Classteam -- Schoolclass 					& Ein Klassenteam hat eine beliebige Anzahl 
	Schulklassen, eine Schulklasse ist aber immer nur genau einem oder keinem Klassteam zugeordnet.\\\hline
22	& Classteam -- Employee 					& Ein Klassteam hat mindestens einen bis zu 
	einer beliebigen Anzahl Mitarbeiter. Wobei Klassenteams ohne mindestens eine Lehrkraft auf Logikebene verhindert werden müssen. Ein Mitarbeiter kann Teil mehrere Klassenteams sein. \\\hline
23	& TravelTimeList -- Edge 					& Ein TravelTimeList-Objekt kann eine beliebige
	Anzahl von Edge-Objekten besitzen. Ein Edge-Objekt kann nur Teil eines TravelTimeList-Objektes sein. \\\hline
24	& Edge -- Location							& Einer beliebigen Anzahl von Edge-Objekten kann 
	eine beliebige Anzahl von Location-Objekten gegenüberstehen. Ein Edge-Objekt hat aber immer zwei disjunkte Location-Objekte.\\\hline 
\end{tabularx}
\subsection{Datentypen und Repräsentation von Multiplizitäten}

Diese Abbildung stellt eine andere Sichtweise auf das vorher gezeigte Klassendiagramm von. Es wurden alle Assoziationen weggelassen und dafür die Attribute an die entsprechenden Klassen eingetragen.
\begin{figure}[H]
\includegraphics[width=\textwidth]{datensicht.pdf}
\end{figure}


\subsection{Abbildung auf die Datenbank}
Die Abbildung auf die Datenbank erfolgt mithilfe des JPA-Frameworks Eclipselink. Damit muss lediglich darauf geachtet werden, die Attribute in den Klassen korrekt mit den One-To-Many- und Many-To-Many-Beziehungen gemäß des Datenmodells zu annotieren.


\section{Ausführungssicht}
\nurlangversion

\label{sec:ausfuehrung}

{\it
Die Ausführungssicht beschreibt das Laufzeitverhalten. Hier
werden die Laufzeitelemente aufgeführt und beschrieben, welche Module
sie zur Ausführung bringen. Ein Modul kann von mehreren
Laufzeitelementen zur Laufzeit verwendet werden. Die Ausführungssicht
beschreibt darüber hinaus, welche Laufzeitelemente spezifisch
miteinander kommunizieren. Zudem wird bei verteilten Systemen
(z.B. Client-Server-Systeme) dargestellt, welche Module von welchen
Prozessen auf welchen Rechnern ausgeführt werden.}


\section[Zusammenhänge zwischen Anwendungsfällen und Architektur]{Zusammenhänge zwischen Anwendungsfällen und Architektur\sectionmark{Zusammenhänge AF u. Architektur}}
\sectionmark{Zusammenhänge AF u. Architektur}
\label{sec:anwendungsfaelle}

\subsection{Hinzufügen einer Aktivität (Unterrichtsstunde)}
Das auf der folgenden Seite dargestellte Sequenzdiagramm zeigt den Ablauf des Hinzufügens eines Lesson-Objektes. Nach Aufruf von \textit{addLesson} wird zunächst die Methode \textit{validateActivity(Activity, TimePeriod)} auf dem \texttt{ActivityValidator} aufgerufen. Diese Methode prüft, ob die Aktivität den Stundenplänen von allen gewählten Teilnehmern hinzugefügt werden kann oder ob es dabei zu Überschneidungen kommt.\\
Liegen keine Überschneidungen vor wird ein \texttt{SuccessStatus} zurückgegeben. In diesem Fall wird dann die Methode \textit{createEmployeeUpdateAddWorkingHours(Activity)} der Klasse \texttt{CommandCreator} aufgerufen. Diese erzeugt ein \texttt{MacroCommand}, welches allen an der Aktivität teilnehmenden Mitarbeitern die Dauer ihrer Teilnahme zu den verteilten Stunden hinzufügt, also deren Auslastung erhöht. Der Prozess der Macro-Erstellung ist im Diagramm auch aufgeführt, soll hier aber nicht näher erläutert werden. Das erzeugte \texttt{MacroCommand} wird schließlich an den \texttt{LessonController} zurückgegeben (1.2.10).\\
Dieser ruft auf dem \texttt{MacroCommand} noch die Methode \textit{add(ICommand)} auf und fügt ihm ein neues \texttt{AddCommand} für die Aktivität hinzu. \\
Anschließend wird die Methode \textit{execute(ICommand)} auf dem \texttt{CommandHandler} mit dem vorher erzeugten \texttt{MacroCommand} als Parameter aufgerufen. Der \texttt{CommandHandler} ruft auf dem Command die \textit{execute}-Methode auf. Da der \texttt{CommandHandler} nicht weiß, was für ein konkretes Command er ausführt, ist der weitere Ablauf im Diagramm nicht dargestellt. In diesem Fall würde der \texttt{CommandHandler} ein \texttt{MacroCommand} ausführen, welches aus einer beliebigen Zahl \texttt{UpdateCommands} und zuletzt einem \texttt{AddCommand} bestehen würde. Die Ausführung dieser Commands würde dann jeweils die Methode \textit{update(Entity)} bzw. \textit{add(Entity)} der Klasse \texttt{DataAccess} aufrufen.\\
Wird von dem \textit{execute}-Aufruf ein \texttt{SuccessStatus} zurückgegeben, wird das Command der Undo-Liste hinzugefügt und die Redo-Liste wird komplett geleert. Das vom Aufruf der \textit{execute}-Methode auf dem Command erhaltene \texttt{IStatus}-Objekt wird an den \texttt{LessonController} zurückgegeben (1.6.5). \\
Handelt es sich bei dem zurückgegebenen \texttt{IStatus}-Objekt um einen \texttt{SuccessStatus}, wird die \textit{init}-Methode des \texttt{LessonController} aufgerufen.\\
Anschließend wird auf dem \texttt{ScheduleModelHolder} die Methode \textit{updateScheduleModel} aufgerufen, um den Stundenplan zu aktualisieren. Auf dem vorher erhaltenen \textit{IStatus}-Objekt wird dann die Methode \textit{report} aufgerufen, welche eine \texttt{FacesMessage} zurückgibt. Diese wird dem \texttt{FacesContext} hinzugefügt. \\
Damit ist das Hinzufügen des \texttt{Lesson}-Objektes abgeschlossen.

\includepdf[landscape]{addLessonSequence.pdf}


\subsection{Hinzufügen einer Lehrkraft}
Das Sequenzdiagramm auf der nächsten Seite stellt den Ablauf des Hinzufügens einer Lehrkraft dar. Nach dem Aufruf von \textit{addTeacher} auf dem \texttt{TeacherController} wird zunächst ein neues \texttt{AddCommand} erstellt. Dieses wird als Parameter an die Methode \textit{execute(ICommand)} des \texttt{CommandHandler} übergeben. Der \texttt{CommandHandler} ruft dann die \textit{execute}-Methode auf dem Command auf. Diese ruft auf dem  enthaltenen \texttt{Entity}-Objekt die \textit{persist}-Methode auf, welche die \textit{persist(Entity)}- Methode der Klasse \texttt{DataAccess} mit dem \texttt{Entity}-Objekt selbst als Parameter aufruft. Dadurch wird dieses Objekt in der Datenbank gespeichert. Anschließend wird, wenn kein Fehler auftritt, ein neues \texttt{SuccessStatus}-Objekt erstellt und an den \texttt{CommandHandler} zurückgegeben.\\
Der \texttt{CommandHandler} fügt dann, wenn ein \texttt{SuccessStatus} zurückgegeben wurde, das ausgeführte \texttt{AddCommand} der Undo-Liste hinzu und leert die Redo-Liste. Anschließend wird das \texttt{IStatus}-Objekt an den \texttt{TeacherController} zurückgegeben.\\
Dort wird auf dem \texttt{IStatus}-Objekt zunächst die \textit{report}-Methode aufgerufen, welche eine \texttt{FacesMessage} zurückgibt, die über den Erfolg bzw. Misserfolg informiert. Wenn das erhaltene \texttt{IStatus}-Objekt außerdem ein Objekt vom Typ \texttt{SuccessStatus} ist, wird ein neuer Lehrer im \texttt{TeacherController} angelegt. Dies ist notwendig, damit beim nächsten Hinzufügen eines Lehrers nicht auf demselben Lehrer-Objekt gearbeitet wird.\\
Schließlich wird die vorher erhaltene \texttt{FacesMessage} dem \texttt{FacesContext} hinzugefügt. Damit ist das Hinzufügen der Lehrkraft abgeschlossen.


\includepdf[landscape]{addTeacherSequence.pdf}

\section{Evolution}
\nurlangversion

\label{sec:evolution}

{\it
  Beschreibt in diesem Abschnitt, welche Änderungen Ihr
  vornehmen müsst, wenn sich Anforderungen oder Rahmenbedingungen
  ändern. Insbesondere sollten hierbei die in der
  Anforderungsspezifikation unter "`Ausblick"' bereits genannten
  Punkte behandelt werden.}

\dots


\end{document} 
